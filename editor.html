<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MISFITS Civil War – Editor</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.draw (client-side drawing) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- html2canvas for PNG export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    :root {
      --bg: #0f172a;         /* slate-900 */
      --panel: #111827cc;    /* semi-opaque slate */
      --text: #e5e7eb;       /* gray-200 */
      --tfr: #3b82f6;
      --sc:  #ef4444;
      --cub: #8b5cf6;
      --neutral: #9ca3af;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); }
    #map { position: absolute; inset: 0; background: #0b1024; }
    .panel {
      position: absolute; top: 10px; left: 10px;
      background: var(--panel); border-radius: 12px; padding: 10px 12px;
      display: grid; grid-template-columns: 1fr; gap: 8px; z-index: 9999;
      backdrop-filter: blur(6px);
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row label { font-size: 12px; opacity: 0.9; }
    .row select, .row button, .row input[type="date"] {
      background: #0b1220; color: var(--text);
      border: 1px solid #374151; border-radius: 8px; padding: 6px 8px; font-size: 12px;
    }
    .row button { cursor: pointer; }
    .legend {
      position: absolute; bottom: 10px; right: 10px;
      background: var(--panel); padding: 8px 10px; border-radius: 10px; font-size: 12px;
      display: grid; gap: 6px;
    }
    .dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; margin-right: 6px; }
    .label-pane .state-label{
      font: 700 11px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:#f8fafc;
      text-shadow:0 0 2px #000,0 0 3px #000,0 0 4px #000;
      pointer-events:none; user-select:none;
    }
    .leaflet-container a { color: #cbd5e1; }
  </style>
</head>
<body>

<div class="panel">
  <div class="row">
    <label>Faction</label>
    <select id="faction">
      <option value="TFR">Task Force Reaper (TFR)</option>
      <option value="SC">Shadow Company (SC)</option>
      <option value="CUB">Cubists (CUB)</option>
      <option value="NEUTRAL">Neutral / Unspecified</option>
    </select>

    <label>Tool</label>
    <select id="toolKind">
      <option value="pocket">Pocket (Polygon)</option>
      <option value="supply">Supply Line (Polyline)</option>
      <option value="unit">Unit / Marker (Point)</option>
    </select>

    <label>Marker</label>
    <select id="markerKind">
      <option value="unit">Unit</option>
      <option value="hq">HQ</option>
    </select>

    <label>Date</label>
    <input id="editDate" type="date" />
  </div>

  <div class="row">
    <button id="btnExport">Export layers (JSON)</button>
    <button id="btnExportPng">Export map (PNG)</button>
    <label>Import JSON <input id="fileImport" type="file" accept=".json,application/json" /></label>
  </div>

  <div class="row">
    <label><input id="chkBorders" type="checkbox" checked> Borders</label>
    <label><input id="chkLabels" type="checkbox" checked> Codes</label>
    <label><input id="chkPOI" type="checkbox"> POIs</label>
  </div>
</div>

<div id="map"></div>

<div class="legend">
  <div><span class="dot" style="background:var(--tfr)"></span>Task Force Reaper</div>
  <div><span class="dot" style="background:var(--sc)"></span>Shadow Company</div>
  <div><span class="dot" style="background:var(--cub)"></span>Cubists</div>
  <div><span class="dot" style="background:var(--neutral)"></span>Neutral</div>
</div>

<script>
  // ---- base map ----
  const map = L.map('map', { zoomControl: true, attributionControl: false, preferCanvas: true })
                .setView([39.5, -98.35], 4);

  // Camera: allow full US including AK/HI; start on lower-48
  const lower48 = L.latLngBounds([24.396308, -124.848974], [49.384358, -66.885444]);
  const usAll   = L.latLngBounds([18.0, -179.9], [72.0, -60.0]);
  map.setMaxBounds(usAll); map.setMinZoom(3); map.fitBounds(lower48);

  // State styles
  const styleBorders = { color: '#9aa4b2', weight: 1, opacity: 0.8, fillOpacity: 0 };
  const styleHiddenBorders = { color: '#9aa4b2', weight: 0, opacity: 0, fillOpacity: 0 };

  // Load states
  let statesLayer;
  fetch('data/us-states.geojson', {cache:'no-store'})
    .then(r => r.json())
    .then(geo => {
      statesLayer = L.geoJSON(geo, { style: styleBorders }).addTo(map);
      buildLabels(statesLayer);
      if (document.getElementById('chkLabels').checked) labelLayer.addTo(map);
    });

  // ---- Labels ----
  map.createPane('labelPane'); 
  map.getPane('labelPane').classList.add('label-pane');
  map.getPane('labelPane').style.zIndex = 650;
  let labelLayer = L.layerGroup([], {pane: 'labelPane'});
  // Explicit overrides incl. AK/HI
  const OV = {
    'AK':[64.5,-152.5],'HI':[20.8,-157.5],
    'CT':[41.6,-72.5],'RI':[41.7,-71.6],'MA':[42.3,-71.8],'NJ':[40.2,-74.5],
    'DE':[39.1,-75.4],'MD':[39.3,-76.8],'NH':[43.8,-71.6],'VT':[44.2,-72.7],'DC':[38.9,-77.03],
    'MI':[44.75,-86.0],'FL':[28.7,-82.0],'LA':[31.0,-92.5]
  };
  function getCode(f){
    const p=f.properties||{}; return p.STUSPS||p.postal||p.state_code||f.id||p.name||'??';
  }
  function buildLabels(geojsonLayer){
    labelLayer.clearLayers();
    geojsonLayer.eachLayer(layer => {
      const c = getCode(layer.feature);
      const pos = OV[c] || layer.getBounds().getCenter();
      const mk = L.marker(pos, {pane: 'labelPane', interactive: false, 
        icon: L.divIcon({className:'state-label', html:c, iconSize:[24,14], iconAnchor:[12,7]})});
      labelLayer.addLayer(mk);
    });
  }

  document.getElementById('chkLabels').addEventListener('change', (e)=>{
    if(e.target.checked) labelLayer.addTo(map); else map.removeLayer(labelLayer);
  });
  document.getElementById('chkBorders').addEventListener('change', (e)=>{
    const s = e.target.checked ? styleBorders : styleHiddenBorders;
    statesLayer && statesLayer.setStyle(s);
  });

  // ---- Draw: single edit group for reliable Save/Cancel ----
  const editGroup = new L.FeatureGroup().addTo(map);  // all created layers go here
  const pockets = new L.FeatureGroup().addTo(map);   // polygons
  const lines   = new L.FeatureGroup().addTo(map);   // polylines
  const points  = new L.FeatureGroup().addTo(map);   // markers

  const editToolbar = new L.Control.Draw({
    edit: { featureGroup: editGroup },
    draw: false // we'll programmatically enable the chosen tool
  });
  map.addControl(editToolbar);

  function factionColor(v){
    if(v==='TFR') return getComputedStyle(document.documentElement).getPropertyValue('--tfr').trim();
    if(v==='SC')  return getComputedStyle(document.documentElement).getPropertyValue('--sc').trim();
    if(v==='CUB') return getComputedStyle(document.documentElement).getPropertyValue('--cub').trim();
    return getComputedStyle(document.documentElement).getPropertyValue('--neutral').trim();
  }

  function markerIcon(){
    const kind = document.getElementById('markerKind').value;
    const size = kind==='hq' ? 20 : 18;
    const path = kind==='hq' ? 'data/icons/hq.png' : 'data/icons/unit.png';
    const ico = L.icon({ iconUrl: path, iconSize:[size,size], iconAnchor:[size/2,size/2] });
    // fallback to text symbol
    const fallback = L.divIcon({className:'state-label', html:(kind==='hq'?'✖':'◆'), iconSize:[size,size], iconAnchor:[size/2,size/2]});
    return ico; // browsers will still try load; if missing it shows broken img, but you can add PNGs later
  }

  let activeHandler = null;
  function enableDraw(){
    if (activeHandler) try { activeHandler.disable(); } catch(e){}
    const tool = document.getElementById('toolKind').value;
    const col  = factionColor(document.getElementById('faction').value);
    if (tool==='pocket'){
      activeHandler = new L.Draw.Polygon(map, { shapeOptions:{ color:col, weight:1, fillColor:col, fillOpacity:0.35 } });
    } else if (tool==='supply'){
      activeHandler = new L.Draw.Polyline(map, { shapeOptions:{ color:col, weight:5, opacity:0.95 } });
    } else {
      activeHandler = new L.Draw.Marker(map, { icon: markerIcon() });
    }
    activeHandler.enable();
  }

  document.getElementById('toolKind').addEventListener('change', enableDraw);
  document.getElementById('faction').addEventListener('change', enableDraw);
  document.getElementById('markerKind').addEventListener('change', enableDraw);
  enableDraw(); // arm once

  map.on(L.Draw.Event.CREATED, function (e) {
    const {layerType, layer} = e;
    const faction = document.getElementById('faction').value;
    const date = document.getElementById('editDate').value || null;

    if (layerType === 'polygon') {
      layer.setStyle({ color: factionColor(faction), fillColor: factionColor(faction), fillOpacity: 0.35, weight: 1 });
      pockets.addLayer(layer);
      layer.feature = { type:'Feature', properties: { kind:'pocket', faction, date }, geometry:{} };
    } else if (layerType === 'polyline') {
      layer.setStyle({ color: factionColor(faction), weight: 5, opacity: 0.95 });
      lines.addLayer(layer);
      layer.feature = { type:'Feature', properties: { kind:'supply', faction, date }, geometry:{} };
    } else if (layerType === 'marker') {
      points.addLayer(layer);
      layer.feature = { type:'Feature', properties: { kind:'unit', icon: document.getElementById('markerKind').value, faction, date }, geometry:{} };
    }

    editGroup.addLayer(layer);
    setTimeout(enableDraw, 0);
  });

  // Export/import helpers
  function toFC(group){
    const feats = [];
    group.eachLayer(l => {
      const gj = l.toGeoJSON();
      if (l.feature && l.feature.properties) gj.properties = Object.assign({}, gj.properties||{}, l.feature.properties);
      feats.push(gj);
    });
    return { type:'FeatureCollection', features:feats };
  }

  function download(filename, text){
    const blob = new Blob([text], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), { href: url, download: filename });
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  document.getElementById('btnExport').addEventListener('click', ()=>{
    const out = { pockets: toFC(pockets), lines: toFC(lines), points: toFC(points) };
    download('warlayers.json', JSON.stringify(out, null, 2));
  });

  document.getElementById('fileImport').addEventListener('change', (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    const r = new FileReader();
    r.onload = ()=>{
      try {
        const data = JSON.parse(String(r.result));
        function addFC(fc, target, kind){
          if(!fc || !fc.features) return;
          fc.features.forEach(ft => {
            const lay = L.geoJSON(ft, {
              style: (ft.geometry.type==='LineString') ? { color:factionColor(ft.properties?.faction), weight:5, opacity:0.95 } :
                    (ft.geometry.type==='Polygon' || ft.geometry.type==='MultiPolygon') ? { color:factionColor(ft.properties?.faction), weight:1, fillColor:factionColor(ft.properties?.faction), fillOpacity:0.35 } :
                    undefined,
              pointToLayer: (ft, latlng) => L.marker(latlng, { icon: markerIcon() })
            });
            lay.eachLayer(l => { l.feature = {type:'Feature', properties: Object.assign({kind}, ft.properties||{}), geometry:{} }; target.addLayer(l); editGroup.addLayer(l); });
          });
        }
        addFC(data.pockets, pockets, 'pocket');
        addFC(data.lines,   lines,   'supply');
        addFC(data.points,  points,  'unit');
        alert('Imported. You can continue editing and export again.');
      } catch(err){ alert('Invalid JSON'); }
    };
    r.readAsText(f);
  });

  document.getElementById('btnExportPng').addEventListener('click', async ()=>{
    const prev = { center: map.getCenter(), zoom: map.getZoom() };
    map.fitBounds(usAll, { animate:false, padding:[10,10] });
    await new Promise(r => setTimeout(r, 150));
    const node = document.getElementById('map');
    const canvas = await html2canvas(node, {useCORS:true, backgroundColor:null});
    const url = canvas.toDataURL('image/png');
    const a = Object.assign(document.createElement('a'), { href: url, download: 'misfits-map.png' });
    document.body.appendChild(a); a.click(); a.remove();
    map.setView(prev.center, prev.zoom, { animate:false });
  });
</script>

</body>
</html>
